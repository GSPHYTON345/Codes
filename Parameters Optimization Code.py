# -*- coding: utf-8 -*-
"""Untitled23.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ba2aP7rolZq8KnR3DenvRamxfZAOqMQP
"""

import numpy as np
import pandas as pd
import talib as ta
from datetime import datetime, time
from skopt import gp_minimize, dummy_minimize
from skopt.space import Integer, Real
from skopt.utils import use_named_args
from google.colab import drive
from joblib import Parallel, delayed
import time as tm

drive.mount('/content/drive')

# Define the path to your CSV file in Google Drive
file_path = '/content/drive/My Drive/GBEBROKERS_EURUSD_7.csv'

# Read the CSV file into a DataFrame
data = pd.read_csv(file_path)

# Select only the required columns
data = data[['time', 'open', 'high', 'low', 'close']]

# Convert the 'time' column to datetime
data['time'] = pd.to_datetime(data['time'], unit='s', errors='coerce')
data.dropna(subset=['time'], inplace=True)
data.set_index('time', inplace=True)

def calculate_supertrend(data, atr_period, multiplier):
    data['ATR'] = ta.ATR(data['high'], data['low'], data['close'], timeperiod=atr_period)
    data['hl2'] = (data['high'] + data['low']) / 2
    data['Upper_Band'] = data['hl2'] - (multiplier * data['ATR'])
    data['Lower_Band'] = data['hl2'] + (multiplier * data['ATR'])
    data['Supertrend'] = np.nan
    data['Trend'] = np.nan

    for i in range(1, len(data)):
        if np.isnan(data['Trend'].iloc[i-1]):
            data.loc[data.index[i], 'Trend'] = 1
        elif data['close'].iloc[i] > data['Lower_Band'].iloc[i-1]:
            data.loc[data.index[i], 'Trend'] = 1
        elif data['close'].iloc[i] < data['Upper_Band'].iloc[i-1]:
            data.loc[data.index[i], 'Trend'] = -1
        else:
            data.loc[data.index[i], 'Trend'] = data['Trend'].iloc[i-1]

        if data['Trend'].iloc[i] == 1:
            data.loc[data.index[i], 'Upper_Band'] = max(data['Upper_Band'].iloc[i], data['Upper_Band'].iloc[i-1])
        else:
            data.loc[data.index[i], 'Lower_Band'] = min(data['Lower_Band'].iloc[i], data['Lower_Band'].iloc[i-1])

        supertrend_value = data['Upper_Band'].iloc[i] if data['Trend'].iloc[i] == 1 else data['Lower_Band'].iloc[i]
        data.loc[data.index[i], 'Supertrend'] = round(supertrend_value, 5)

    return data

def run_backtest(data, atr_period, multiplier, fast_length, slow_length, signal_length):
    if fast_length >= slow_length or fast_length <= 0 or slow_length <= 0:
        return 0, 0, 0

    data = calculate_supertrend(data, atr_period, multiplier)

    try:
        data['MACD'], data['Signal'], data['Hist'] = ta.MACD(data['close'], fastperiod=fast_length, slowperiod=slow_length, signalperiod=signal_length)
    except Exception as e:
        return 0, 0, 0

    data['MACD'] = data['MACD'].round(5)
    data['Signal'] = data['Signal'].round(5)
    data['Hist'] = data['Hist'].round(5)

    if not pd.api.types.is_datetime64_any_dtype(data.index):
        data.index = pd.to_datetime(data.index)

    def within_time_range(timestamp):
        return time(6, 30) <= timestamp.time() <= time(19, 30)

    data['WithinTime'] = data.index.map(within_time_range)

    data['LongCondition'] = (data['Trend'] == 1) & (data['MACD'] > data['Signal']) & (data['close'] > data['Supertrend']) & (data['Trend'].shift(1) == -1) & data['WithinTime']
    data['ShortCondition'] = (data['Trend'] == -1) & (data['MACD'] < data['Signal']) & (data['close'] < data['Supertrend']) & (data['Trend'].shift(1) == 1) & data['WithinTime']

    initial_equity = 100000
    equity = initial_equity

    def calculate_position_size(equity, entry_price, stop_loss_price):
        risk_per_trade = equity * 0.01
        risk_pips = abs(entry_price - stop_loss_price)
        qty = risk_per_trade / risk_pips
        return qty

    trades = []
    equity_curve = [equity]
    current_trades = []

    for i in range(1, len(data)):
        if data['LongCondition'].iloc[i] or data['ShortCondition'].iloc[i]:
            if data['LongCondition'].iloc[i]:
                entry_price = data['close'].iloc[i]
                stop_loss = data['Supertrend'].iloc[i]
                take_profit = entry_price + (abs(entry_price - stop_loss) * 2)
                qty = calculate_position_size(equity, entry_price, stop_loss)
                new_trade = {
                    'Type': 'Long',
                    'EntryTime': data.index[i],
                    'EntryPrice': entry_price,
                    'StopLoss': stop_loss,
                    'TakeProfit': take_profit,
                    'Qty': qty,
                    'ExitPrice': np.nan,
                    'ExitTime': np.nan,
                    'Profit': np.nan,
                    'Outcome': 'Open'
                }
                current_trades.append(new_trade)
            elif data['ShortCondition'].iloc[i]:
                entry_price = data['close'].iloc[i]
                stop_loss = data['Supertrend'].iloc[i]
                take_profit = entry_price - (abs(entry_price - stop_loss) * 2)
                qty = calculate_position_size(equity, entry_price, stop_loss)
                new_trade = {
                    'Type': 'Short',
                    'EntryTime': data.index[i],
                    'EntryPrice': entry_price,
                    'StopLoss': stop_loss,
                    'TakeProfit': take_profit,
                    'Qty': qty,
                    'ExitPrice': np.nan,
                    'ExitTime': np.nan,
                    'Profit': np.nan,
                    'Outcome': 'Open'
                }
                current_trades.append(new_trade)

        for trade in current_trades:
            if trade['Outcome'] == 'Open':
                if trade['Type'] == 'Long' and data['ShortCondition'].iloc[i]:
                    trade['Outcome'] = 'Closed for Reverse'
                    trade['ExitPrice'] = data['close'].iloc[i]
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                    if not any(t['Type'] == 'Short' and t['Outcome'] == 'Open' for t in current_trades):
                        entry_price = data['close'].iloc[i]
                        stop_loss = data['Supertrend'].iloc[i]
                        take_profit = entry_price - (abs(entry_price - stop_loss) * 2)
                        qty = calculate_position_size(equity, entry_price, stop_loss)
                        reverse_trade = {
                            'Type': 'Short',
                            'EntryTime': data.index[i],
                            'EntryPrice': entry_price,
                            'StopLoss': stop_loss,
                            'TakeProfit': take_profit,
                            'Qty': qty,
                            'ExitPrice': np.nan,
                            'ExitTime': np.nan,
                            'Profit': np.nan,
                            'Outcome': 'Open'
                        }
                        current_trades.append(reverse_trade)
                elif trade['Type'] == 'Short' and data['LongCondition'].iloc[i]:
                    trade['Outcome'] = 'Closed for Reverse'
                    trade['ExitPrice'] = data['close'].iloc[i]
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                    if not any(t['Type'] == 'Long' and t['Outcome'] == 'Open' for t in current_trades):
                        entry_price = data['close'].iloc[i]
                        stop_loss = data['Supertrend'].iloc[i]
                        take_profit = entry_price + (abs(entry_price - stop_loss) * 2)
                        qty = calculate_position_size(equity, entry_price, stop_loss)
                        reverse_trade = {
                            'Type': 'Long',
                            'EntryTime': data.index[i],
                            'EntryPrice': entry_price,
                            'StopLoss': stop_loss,
                            'TakeProfit': take_profit,
                            'Qty': qty,
                            'ExitPrice': np.nan,
                            'ExitTime': np.nan,
                            'Profit': np.nan,
                            'Outcome': 'Open'
                        }
                        current_trades.append(reverse_trade)
                elif trade['Type'] == 'Long' and data['low'].iloc[i] < trade['StopLoss']:
                    trade['Outcome'] = 'Loss'
                    trade['ExitPrice'] = trade['StopLoss']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Long' and data['high'].iloc[i] > trade['TakeProfit']:
                    trade['Outcome'] = 'Win'
                    trade['ExitPrice'] = trade['TakeProfit']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Short' and data['high'].iloc[i] > trade['StopLoss']:
                    trade['Outcome'] = 'Loss'
                    trade['ExitPrice'] = trade['StopLoss']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Short' and data['low'].iloc[i] < trade['TakeProfit']:
                    trade['Outcome'] = 'Win'
                    trade['ExitPrice'] = trade['TakeProfit']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)

        current_trades = [trade for trade in current_trades if trade['Outcome'] == 'Open']
        equity_curve.append(equity)

    trades_df = pd.DataFrame(trades)
    win_rate = len(trades_df[trades_df['Outcome'] == 'Win']) / len(trades_df) if len(trades_df) > 0 else 0
    equity_series = pd.Series(equity_curve)
    drawdown = equity_series / equity_series.cummax() - 1
    max_drawdown = drawdown.min() if len(drawdown) > 0 else 0

    return equity, win_rate, max_drawdown

space = [
    Integer(1, 25, name='atr_period'),
    Real(0.1, 5.0, name='multiplier'),
    Integer(2, 150, name='fast_length'),
    Integer(2, 150, name='slow_length'),
    Integer(2, 150, name='signal_length')
]

@use_named_args(space)
def objective(atr_period, multiplier, fast_length, slow_length, signal_length):
    final_equity, win_rate, max_drawdown = run_backtest(data.copy(), atr_period, multiplier, fast_length, slow_length, signal_length)
    return -final_equity

# Function to execute random search with time limit
def execute_random_search_with_time_limit():
    start_time = tm.time()
    n_calls = 0
    results = []

    while tm.time() - start_time < 3600:  # 1 hour limit
        result = dummy_minimize(objective, space, n_calls=1, random_state=n_calls)
        results.append(result)
        n_calls += 1

    return results

# Perform Initial Random Search with time limit
random_search_results = execute_random_search_with_time_limit()
initial_best_params = min(random_search_results, key=lambda x: x.fun).x
print(f"Initial Best parameters: ATR Period: {initial_best_params[0]}, Multiplier: {initial_best_params[1]}, Fast Length: {initial_best_params[2]}, Slow Length: {initial_best_params[3]}, Signal Length: {initial_best_params[4]}")

# Refine Search with Gaussian Process Optimization
refined_space = [
    Integer(max(1, initial_best_params[0] - 5), min(25, initial_best_params[0] + 5), name='atr_period'),
    Real(max(0.1, initial_best_params[1] - 0.5), min(5.0, initial_best_params[1] + 0.5), name='multiplier'),
    Integer(max(2, initial_best_params[2] - 5), min(150, initial_best_params[2] + 5), name='fast_length'),
    Integer(max(2, initial_best_params[3] - 10), min(150, initial_best_params[3] + 10), name='slow_length'),
    Integer(max(2, initial_best_params[4] - 5), min(150, initial_best_params[4] + 5), name='signal_length')
]

@use_named_args(refined_space)
def refined_objective(atr_period, multiplier, fast_length, slow_length, signal_length):
    final_equity, win_rate, max_drawdown = run_backtest(data.copy(), atr_period, multiplier, fast_length, slow_length, signal_length)
    return -final_equity

refined_result = gp_minimize(refined_objective, refined_space, n_calls=50, random_state=0)

best_params = refined_result.x
print(f"Refined Best parameters: ATR Period: {best_params[0]}, Multiplier: {best_params[1]}, Fast Length: {best_params[2]}, Slow Length: {best_params[3]}, Signal Length: {best_params[4]}")

# Collect all results
results = []

for params in refined_result.x_iters:
    final_equity, win_rate, max_drawdown = run_backtest(data.copy(), *params)
    results.append((params, final_equity, win_rate, max_drawdown))

results_df = pd.DataFrame(results, columns=['params', 'final_equity', 'win_rate', 'max_drawdown'])

# Print the 10 best combinations for net profit
print("Top 10 Combinations by Net Profit:")
print(results_df.nlargest(10, 'final_equity'))

# Print the 10 best combinations for win rate
print("Top 10 Combinations by Win Rate:")
print(results_df.nlargest(10, 'win_rate'))

# Print the 10 best combinations for drawdown
print("Top 10 Combinations by Lowest Drawdown:")
print(results_df.nsmallest(10, 'max_drawdown'))

!pip install deap
import numpy as np
import pandas as pd
import talib as ta
from datetime import datetime, time
from google.colab import drive
from deap import base, creator, tools, algorithms
import random

drive.mount('/content/drive')

# Define the path to your CSV file in Google Drive
file_path = '/content/drive/My Drive/GBEBROKERS_EURUSD, 5 MARZO.csv'

# Read the CSV file into a DataFrame
data = pd.read_csv(file_path)

# Select only the required columns
data = data[['time', 'open', 'high', 'low', 'close']]

# Convert the 'time' column to datetime
data['time'] = pd.to_datetime(data['time'], unit='s', errors='coerce')
data.dropna(subset=['time'], inplace=True)
data.set_index('time', inplace=True)

def calculate_supertrend(data, atr_period, multiplier):
    data['ATR'] = ta.ATR(data['high'], data['low'], data['close'], timeperiod=atr_period)
    data['hl2'] = (data['high'] + data['low']) / 2
    data['Upper_Band'] = data['hl2'] - (multiplier * data['ATR'])
    data['Lower_Band'] = data['hl2'] + (multiplier * data['ATR'])
    data['Supertrend'] = np.nan
    data['Trend'] = np.nan

    for i in range(1, len(data)):
        if np.isnan(data['Trend'].iloc[i-1]):
            data.loc[data.index[i], 'Trend'] = 1
        elif data['close'].iloc[i] > data['Lower_Band'].iloc[i-1]:
            data.loc[data.index[i], 'Trend'] = 1
        elif data['close'].iloc[i] < data['Upper_Band'].iloc[i-1]:
            data.loc[data.index[i], 'Trend'] = -1
        else:
            data.loc[data.index[i], 'Trend'] = data['Trend'].iloc[i-1]

        if data['Trend'].iloc[i] == 1:
            data.loc[data.index[i], 'Upper_Band'] = max(data['Upper_Band'].iloc[i], data['Upper_Band'].iloc[i-1])
        else:
            data.loc[data.index[i], 'Lower_Band'] = min(data['Lower_Band'].iloc[i], data['Lower_Band'].iloc[i-1])

        supertrend_value = data['Upper_Band'].iloc[i] if data['Trend'].iloc[i] == 1 else data['Lower_Band'].iloc[i]
        data.loc[data.index[i], 'Supertrend'] = round(supertrend_value, 5)

    return data

def run_backtest(data, atr_period, multiplier, fast_length, slow_length, signal_length):
    if fast_length >= slow_length or fast_length <= 0 or slow_length <= 0:
        return 0, 0, 0

    data = calculate_supertrend(data, atr_period, multiplier)

    try:
        data['MACD'], data['Signal'], data['Hist'] = ta.MACD(data['close'], fastperiod=fast_length, slowperiod=slow_length, signalperiod=signal_length)
    except Exception as e:
        return 0, 0, 0

    data['MACD'] = data['MACD'].round(5)
    data['Signal'] = data['Signal'].round(5)
    data['Hist'] = data['Hist'].round(5)

    if not pd.api.types.is_datetime64_any_dtype(data.index):
        data.index = pd.to_datetime(data.index)

    def within_time_range(timestamp):
        return time(6, 30) <= timestamp.time() <= time(19, 30)

    data['WithinTime'] = data.index.map(within_time_range)

    data['LongCondition'] = (data['Trend'] == 1) & (data['MACD'] > data['Signal']) & (data['close'] > data['Supertrend']) & (data['Trend'].shift(1) == -1) & data['WithinTime']
    data['ShortCondition'] = (data['Trend'] == -1) & (data['MACD'] < data['Signal']) & (data['close'] < data['Supertrend']) & (data['Trend'].shift(1) == 1) & data['WithinTime']

    initial_equity = 100000
    equity = initial_equity

    def calculate_position_size(equity, entry_price, stop_loss_price):
        risk_per_trade = equity * 0.01
        risk_pips = abs(entry_price - stop_loss_price)
        qty = risk_per_trade / risk_pips
        return qty

    trades = []
    equity_curve = [equity]
    current_trades = []

    for i in range(1, len(data)):
        if data['LongCondition'].iloc[i] or data['ShortCondition'].iloc[i]:
            if data['LongCondition'].iloc[i]:
                entry_price = data['close'].iloc[i]
                stop_loss = data['Supertrend'].iloc[i]
                take_profit = entry_price + (abs(entry_price - stop_loss) * 2)
                qty = calculate_position_size(equity, entry_price, stop_loss)
                new_trade = {
                    'Type': 'Long',
                    'EntryTime': data.index[i],
                    'EntryPrice': entry_price,
                    'StopLoss': stop_loss,
                    'TakeProfit': take_profit,
                    'Qty': qty,
                    'ExitPrice': np.nan,
                    'ExitTime': np.nan,
                    'Profit': np.nan,
                    'Outcome': 'Open'
                }
                current_trades.append(new_trade)
            elif data['ShortCondition'].iloc[i]:
                entry_price = data['close'].iloc[i]
                stop_loss = data['Supertrend'].iloc[i]
                take_profit = entry_price - (abs(entry_price - stop_loss) * 2)
                qty = calculate_position_size(equity, entry_price, stop_loss)
                new_trade = {
                    'Type': 'Short',
                    'EntryTime': data.index[i],
                    'EntryPrice': entry_price,
                    'StopLoss': stop_loss,
                    'TakeProfit': take_profit,
                    'Qty': qty,
                    'ExitPrice': np.nan,
                    'ExitTime': np.nan,
                    'Profit': np.nan,
                    'Outcome': 'Open'
                }
                current_trades.append(new_trade)

        for trade in current_trades:
            if trade['Outcome'] == 'Open':
                if trade['Type'] == 'Long' and data['ShortCondition'].iloc[i]:
                    trade['Outcome'] = 'Closed for Reverse'
                    trade['ExitPrice'] = data['close'].iloc[i]
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                    if not any(t['Type'] == 'Short' and t['Outcome'] == 'Open' for t in current_trades):
                        entry_price = data['close'].iloc[i]
                        stop_loss = data['Supertrend'].iloc[i]
                        take_profit = entry_price - (abs(entry_price - stop_loss) * 2)
                        qty = calculate_position_size(equity, entry_price, stop_loss)
                        reverse_trade = {
                            'Type': 'Short',
                            'EntryTime': data.index[i],
                            'EntryPrice': entry_price,
                            'StopLoss': stop_loss,
                            'TakeProfit': take_profit,
                            'Qty': qty,
                            'ExitPrice': np.nan,
                            'ExitTime': np.nan,
                            'Profit': np.nan,
                            'Outcome': 'Open'
                        }
                        current_trades.append(reverse_trade)
                elif trade['Type'] == 'Short' and data['LongCondition'].iloc[i]:
                    trade['Outcome'] = 'Closed for Reverse'
                    trade['ExitPrice'] = data['close'].iloc[i]
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                    if not any(t['Type'] == 'Long' and t['Outcome'] == 'Open' for t in current_trades):
                        entry_price = data['close'].iloc[i]
                        stop_loss = data['Supertrend'].iloc[i]
                        take_profit = entry_price + (abs(entry_price - stop_loss) * 2)
                        qty = calculate_position_size(equity, entry_price, stop_loss)
                        reverse_trade = {
                            'Type': 'Long',
                            'EntryTime': data.index[i],
                            'EntryPrice': entry_price,
                            'StopLoss': stop_loss,
                            'TakeProfit': take_profit,
                            'Qty': qty,
                            'ExitPrice': np.nan,
                            'ExitTime': np.nan,
                            'Profit': np.nan,
                            'Outcome': 'Open'
                        }
                        current_trades.append(reverse_trade)
                elif trade['Type'] == 'Long' and data['low'].iloc[i] < trade['StopLoss']:
                    trade['Outcome'] = 'Loss'
                    trade['ExitPrice'] = trade['StopLoss']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Long' and data['high'].iloc[i] > trade['TakeProfit']:
                    trade['Outcome'] = 'Win'
                    trade['ExitPrice'] = trade['TakeProfit']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Short' and data['high'].iloc[i] > trade['StopLoss']:
                    trade['Outcome'] = 'Loss'
                    trade['ExitPrice'] = trade['StopLoss']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Short' and data['low'].iloc[i] < trade['TakeProfit']:
                    trade['Outcome'] = 'Win'
                    trade['ExitPrice'] = trade['TakeProfit']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)

        current_trades = [trade for trade in current_trades if trade['Outcome'] == 'Open']
        equity_curve.append(equity)

    trades_df = pd.DataFrame(trades)
    win_rate = len(trades_df[trades_df['Outcome'] == 'Win']) / len(trades_df) if len(trades_df) > 0 else 0
    equity_series = pd.Series(equity_curve)
    drawdown = equity_series / equity_series.cummax() - 1
    max_drawdown = drawdown.min() if len(drawdown) > 0 else 0

    return equity, win_rate, max_drawdown

# Define Genetic Algorithm optimization
def evaluate(individual):
    atr_period, multiplier, fast_length, slow_length, signal_length = individual
    # Ensure atr_period is within valid range
    atr_period = max(1, min(int(atr_period), 20))  # Adjust 20 based on your data size
    final_equity, win_rate, max_drawdown = run_backtest(data.copy(), atr_period, multiplier, int(fast_length), int(slow_length), int(signal_length))
    return final_equity,

# Define parameter space
creator.create('FitnessMax', base.Fitness, weights=(1.0,))
creator.create('Individual', list, fitness=creator.FitnessMax)

toolbox = base.Toolbox()
toolbox.register('attr_int', random.randint, 1, 25)
toolbox.register('attr_float', random.uniform, 0.1, 5.0)
toolbox.register('individual', tools.initCycle, creator.Individual,
                 (toolbox.attr_int, toolbox.attr_float, toolbox.attr_int, toolbox.attr_int, toolbox.attr_int), n=1)
toolbox.register('population', tools.initRepeat, list, toolbox.individual)
toolbox.register('mate', tools.cxBlend, alpha=0.5)
toolbox.register('mutate', tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register('select', tools.selTournament, tournsize=3)
toolbox.register('evaluate', evaluate)

# Run Genetic Algorithm
population = toolbox.population(n=300)
ngen = 40
cxpb = 0.7
mutpb = 0.2

result, log = algorithms.eaSimple(population, toolbox, cxpb, mutpb, ngen, verbose=True)

# Extract and print top results
top10 = tools.selBest(result, 10)
for i, individual in enumerate(top10):
    params = [int(individual[0]), individual[1], int(individual[2]), int(individual[3]), int(individual[4])]
    final_equity, win_rate, max_drawdown = run_backtest(data.copy(), *params)
    print(f"Top {i+1} Individual: {params} - Net Profit: {final_equity}, Win Rate: {win_rate}, Max Drawdown: {max_drawdown}")

# Grafico ottimizzato
import numpy as np
import pandas as pd
import talib as ta
from datetime import datetime, time
from google.colab import drive
import optuna
from sklearn.model_selection import TimeSeriesSplit

drive.mount('/content/drive')

# Define the path to your CSV file in Google Drive
file_path = '/content/drive/My Drive/GBEBROKERS_EURUSD, 5 MARZO.csv'

# Read the CSV file into a DataFrame
data = pd.read_csv(file_path)

# Select only the required columns
data = data[['time', 'open', 'high', 'low', 'close']]

# Convert the 'time' column to datetime
data['time'] = pd.to_datetime(data['time'], unit='s', errors='coerce')
data.dropna(subset=['time'], inplace=True)
data.set_index('time', inplace=True)

def calculate_supertrend(data, atr_period, multiplier):
    data['ATR'] = ta.ATR(data['high'], data['low'], data['close'], timeperiod=atr_period)
    data['hl2'] = (data['high'] + data['low']) / 2
    data['Upper_Band'] = data['hl2'] - (multiplier * data['ATR'])
    data['Lower_Band'] = data['hl2'] + (multiplier * data['ATR'])
    data['Supertrend'] = np.nan
    data['Trend'] = np.nan

    for i in range(1, len(data)):
        if np.isnan(data['Trend'].iloc[i-1]):
            data.loc[data.index[i], 'Trend'] = 1
        elif data['close'].iloc[i] > data['Lower_Band'].iloc[i-1]:
            data.loc[data.index[i], 'Trend'] = 1
        elif data['close'].iloc[i] < data['Upper_Band'].iloc[i-1]:
            data.loc[data.index[i], 'Trend'] = -1
        else:
            data.loc[data.index[i], 'Trend'] = data['Trend'].iloc[i-1]

        if data['Trend'].iloc[i] == 1:
            data.loc[data.index[i], 'Upper_Band'] = max(data['Upper_Band'].iloc[i], data['Upper_Band'].iloc[i-1])
        else:
            data.loc[data.index[i], 'Lower_Band'] = min(data['Lower_Band'].iloc[i], data['Lower_Band'].iloc[i-1])

        supertrend_value = data['Upper_Band'].iloc[i] if data['Trend'].iloc[i] == 1 else data['Lower_Band'].iloc[i]
        data.loc[data.index[i], 'Supertrend'] = round(supertrend_value, 5)

    return data

def run_backtest(data, atr_period, multiplier, fast_length, slow_length, signal_length):
    if fast_length >= slow_length or fast_length <= 0 or slow_length <= 0:
        return 0, 0, 0, 0

    data = calculate_supertrend(data, atr_period, multiplier)

    try:
        data['MACD'], data['Signal'], data['Hist'] = ta.MACD(data['close'], fastperiod=fast_length, slowperiod=slow_length, signalperiod=signal_length)
    except Exception as e:
        return 0, 0, 0, 0

    data['MACD'] = data['MACD'].round(5)
    data['Signal'] = data['Signal'].round(5)
    data['Hist'] = data['Hist'].round(5)

    if not pd.api.types.is_datetime64_any_dtype(data.index):
        data.index = pd.to_datetime(data.index)

    def within_time_range(timestamp):
        return time(6, 30) <= timestamp.time() <= time(19, 30)

    data['WithinTime'] = data.index.map(within_time_range)

    data['LongCondition'] = (data['Trend'] == 1) & (data['MACD'] > data['Signal']) & (data['close'] > data['Supertrend']) & (data['Trend'].shift(1) == -1) & data['WithinTime']
    data['ShortCondition'] = (data['Trend'] == -1) & (data['MACD'] < data['Signal']) & (data['close'] < data['Supertrend']) & (data['Trend'].shift(1) == 1) & data['WithinTime']

    initial_equity = 100000
    equity = initial_equity

    def calculate_position_size(equity, entry_price, stop_loss_price):
        risk_per_trade = equity * 0.01
        risk_pips = abs(entry_price - stop_loss_price)
        qty = risk_per_trade / risk_pips
        return qty

    trades = []
    equity_curve = [equity]
    current_trades = []

    for i in range(1, len(data)):
        if data['LongCondition'].iloc[i] or data['ShortCondition'].iloc[i]:
            if data['LongCondition'].iloc[i]:
                entry_price = data['close'].iloc[i]
                stop_loss = data['Supertrend'].iloc[i]
                take_profit = entry_price + (abs(entry_price - stop_loss) * 2)
                qty = calculate_position_size(equity, entry_price, stop_loss)
                new_trade = {
                    'Type': 'Long',
                    'EntryTime': data.index[i],
                    'EntryPrice': entry_price,
                    'StopLoss': stop_loss,
                    'TakeProfit': take_profit,
                    'Qty': qty,
                    'ExitPrice': np.nan,
                    'ExitTime': np.nan,
                    'Profit': np.nan,
                    'Outcome': 'Open'
                }
                current_trades.append(new_trade)
            elif data['ShortCondition'].iloc[i]:
                entry_price = data['close'].iloc[i]
                stop_loss = data['Supertrend'].iloc[i]
                take_profit = entry_price - (abs(entry_price - stop_loss) * 2)
                qty = calculate_position_size(equity, entry_price, stop_loss)
                new_trade = {
                    'Type': 'Short',
                    'EntryTime': data.index[i],
                    'EntryPrice': entry_price,
                    'StopLoss': stop_loss,
                    'TakeProfit': take_profit,
                    'Qty': qty,
                    'ExitPrice': np.nan,
                    'ExitTime': np.nan,
                    'Profit': np.nan,
                    'Outcome': 'Open'
                }
                current_trades.append(new_trade)

        for trade in current_trades:
            if trade['Outcome'] == 'Open':
                if trade['Type'] == 'Long' and data['ShortCondition'].iloc[i]:
                    trade['Outcome'] = 'Closed for Reverse'
                    trade['ExitPrice'] = data['close'].iloc[i]
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                    if not any(t['Type'] == 'Short' and t['Outcome'] == 'Open' for t in current_trades):
                        entry_price = data['close'].iloc[i]
                        stop_loss = data['Supertrend'].iloc[i]
                        take_profit = entry_price - (abs(entry_price - stop_loss) * 2)
                        qty = calculate_position_size(equity, entry_price, stop_loss)
                        reverse_trade = {
                            'Type': 'Short',
                            'EntryTime': data.index[i],
                            'EntryPrice': entry_price,
                            'StopLoss': stop_loss,
                            'TakeProfit': take_profit,
                            'Qty': qty,
                            'ExitPrice': np.nan,
                            'ExitTime': np.nan,
                            'Profit': np.nan,
                            'Outcome': 'Open'
                        }
                        current_trades.append(reverse_trade)
                elif trade['Type'] == 'Short' and data['LongCondition'].iloc[i]:
                    trade['Outcome'] = 'Closed for Reverse'
                    trade['ExitPrice'] = data['close'].iloc[i]
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                    if not any(t['Type'] == 'Long' and t['Outcome'] == 'Open' for t in current_trades):
                        entry_price = data['close'].iloc[i]
                        stop_loss = data['Supertrend'].iloc[i]
                        take_profit = entry_price + (abs(entry_price - stop_loss) * 2)
                        qty = calculate_position_size(equity, entry_price, stop_loss)
                        reverse_trade = {
                            'Type': 'Long',
                            'EntryTime': data.index[i],
                            'EntryPrice': entry_price,
                            'StopLoss': stop_loss,
                            'TakeProfit': take_profit,
                            'Qty': qty,
                            'ExitPrice': np.nan,
                            'ExitTime': np.nan,
                            'Profit': np.nan,
                            'Outcome': 'Open'
                        }
                        current_trades.append(reverse_trade)
                elif trade['Type'] == 'Long' and data['low'].iloc[i] < trade['StopLoss']:
                    trade['Outcome'] = 'Loss'
                    trade['ExitPrice'] = trade['StopLoss']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Long' and data['high'].iloc[i] > trade['TakeProfit']:
                    trade['Outcome'] = 'Win'
                    trade['ExitPrice'] = trade['TakeProfit']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Short' and data['high'].iloc[i] > trade['StopLoss']:
                    trade['Outcome'] = 'Loss'
                    trade['ExitPrice'] = trade['StopLoss']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Short' and data['low'].iloc[i] < trade['TakeProfit']:
                    trade['Outcome'] = 'Win'
                    trade['ExitPrice'] = trade['TakeProfit']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)

        current_trades = [trade for trade in current_trades if trade['Outcome'] == 'Open']
        equity_curve.append(equity)

    trades_df = pd.DataFrame(trades)
    win_rate = len(trades_df[trades_df['Outcome'] == 'Win']) / len(trades_df) if len(trades_df) > 0 else 0
    equity_series = pd.Series(equity_curve)
    drawdown = equity_series / equity_series.cummax() - 1
    max_drawdown = drawdown.min() if len(drawdown) > 0 else 0

    sharpe_ratio = (equity_series.pct_change().mean() / equity_series.pct_change().std()) * np.sqrt(252)

    return equity, win_rate, max_drawdown, sharpe_ratio

# Time Series Split for Cross Validation
tscv = TimeSeriesSplit(n_splits=5)

def objective(trial):
    atr_period = trial.suggest_int('atr_period', 5, 25)
    multiplier = trial.suggest_uniform('multiplier', 1.5, 4.0)
    fast_length = trial.suggest_int('fast_length', 5, 150)
    slow_length = trial.suggest_int('slow_length', 10, 150)
    signal_length = trial.suggest_int('signal_length', 5, 115)

    cv_results = []
    for train_index, test_index in tscv.split(data):
        train_data = data.iloc[train_index]
        test_data = data.iloc[test_index]
        final_equity, win_rate, max_drawdown, sharpe_ratio = run_backtest(train_data, atr_period, multiplier, fast_length, slow_length, signal_length)
        cv_results.append(sharpe_ratio)
    return -np.mean(cv_results)

study = optuna.create_study(direction='minimize')
study.optimize(objective, n_trials=200)

best_params = study.best_params
print(f"Refined Best parameters: {best_params}")

# Collect all results
results = []

for trial in study.trials:
    params = trial.params
    final_equity, win_rate, max_drawdown, sharpe_ratio = run_backtest(data.copy(), params['atr_period'], params['multiplier'], params['fast_length'], params['slow_length'], params['signal_length'])
    results.append((params, final_equity, win_rate, max_drawdown, sharpe_ratio))

results_df = pd.DataFrame(results, columns=['params', 'final_equity', 'win_rate', 'max_drawdown', 'sharpe_ratio'])

# Print the 10 best combinations for net profit
print("Top 10 Combinations by Net Profit:")
print(results_df.nlargest(10, 'final_equity'))

# Print the 10 best combinations for win rate
print("Top 10 Combinations by Win Rate:")
print(results_df.nlargest(10, 'win_rate'))

# Print the 10 best combinations for drawdown
print("Top 10 Combinations by Lowest Drawdown:")
print(results_df.nsmallest(10, 'max_drawdown'))

# Print the 10 best combinations for Sharpe Ratio
print("Top 10 Combinations by Sharpe Ratio:")
print(results_df.nlargest(10, 'sharpe_ratio'))

# With machine learning
!pip install optuna
import numpy as np
import pandas as pd
import talib as ta
from datetime import datetime, time
from google.colab import drive
import optuna
from sklearn.model_selection import TimeSeriesSplit

drive.mount('/content/drive')

# Define the path to your CSV file in Google Drive
file_path = '/content/drive/My Drive/GBEBROKERS_EURUSD, 5 MARZO.csv'

# Read the CSV file into a DataFrame
data = pd.read_csv(file_path)

# Select only the required columns
data = data[['time', 'open', 'high', 'low', 'close']]

# Convert the 'time' column to datetime
data['time'] = pd.to_datetime(data['time'], unit='s', errors='coerce')
data.dropna(subset=['time'], inplace=True)
data.set_index('time', inplace=True)

def calculate_supertrend(data, atr_period, multiplier):
    data['ATR'] = ta.ATR(data['high'], data['low'], data['close'], timeperiod=atr_period)
    data['hl2'] = (data['high'] + data['low']) / 2
    data['Upper_Band'] = data['hl2'] - (multiplier * data['ATR'])
    data['Lower_Band'] = data['hl2'] + (multiplier * data['ATR'])
    data['Supertrend'] = np.nan
    data['Trend'] = np.nan

    for i in range(1, len(data)):
        if np.isnan(data['Trend'].iloc[i-1]):
            data.loc[data.index[i], 'Trend'] = 1
        elif data['close'].iloc[i] > data['Lower_Band'].iloc[i-1]:
            data.loc[data.index[i], 'Trend'] = 1
        elif data['close'].iloc[i] < data['Upper_Band'].iloc[i-1]:
            data.loc[data.index[i], 'Trend'] = -1
        else:
            data.loc[data.index[i], 'Trend'] = data['Trend'].iloc[i-1]

        if data['Trend'].iloc[i] == 1:
            data.loc[data.index[i], 'Upper_Band'] = max(data['Upper_Band'].iloc[i], data['Upper_Band'].iloc[i-1])
        else:
            data.loc[data.index[i], 'Lower_Band'] = min(data['Lower_Band'].iloc[i], data['Lower_Band'].iloc[i-1])

        supertrend_value = data['Upper_Band'].iloc[i] if data['Trend'].iloc[i] == 1 else data['Lower_Band'].iloc[i]
        data.loc[data.index[i], 'Supertrend'] = round(supertrend_value, 5)

    return data

def run_backtest(data, atr_period, multiplier, fast_length, slow_length, signal_length):
    if fast_length >= slow_length or fast_length <= 0 or slow_length <= 0:
        return 0, 0, 0

    data = calculate_supertrend(data, atr_period, multiplier)

    try:
        data['MACD'], data['Signal'], data['Hist'] = ta.MACD(data['close'], fastperiod=fast_length, slowperiod=slow_length, signalperiod=signal_length)
    except Exception as e:
        return 0, 0, 0

    data['MACD'] = data['MACD'].round(5)
    data['Signal'] = data['Signal'].round(5)
    data['Hist'] = data['Hist'].round(5)

    if not pd.api.types.is_datetime64_any_dtype(data.index):
        data.index = pd.to_datetime(data.index)

    def within_time_range(timestamp):
        return time(6, 30) <= timestamp.time() <= time(19, 30)

    data['WithinTime'] = data.index.map(within_time_range)

    data['LongCondition'] = (data['Trend'] == 1) & (data['MACD'] > data['Signal']) & (data['close'] > data['Supertrend']) & (data['Trend'].shift(1) == -1) & data['WithinTime']
    data['ShortCondition'] = (data['Trend'] == -1) & (data['MACD'] < data['Signal']) & (data['close'] < data['Supertrend']) & (data['Trend'].shift(1) == 1) & data['WithinTime']

    initial_equity = 100000
    equity = initial_equity

    def calculate_position_size(equity, entry_price, stop_loss_price):
        risk_per_trade = equity * 0.01
        risk_pips = abs(entry_price - stop_loss_price)
        qty = risk_per_trade / risk_pips
        return qty

    trades = []
    equity_curve = [equity]
    current_trades = []

    for i in range(1, len(data)):
        if data['LongCondition'].iloc[i] or data['ShortCondition'].iloc[i]:
            if data['LongCondition'].iloc[i]:
                entry_price = data['close'].iloc[i]
                stop_loss = data['Supertrend'].iloc[i]
                take_profit = entry_price + (abs(entry_price - stop_loss) * 2)
                qty = calculate_position_size(equity, entry_price, stop_loss)
                new_trade = {
                    'Type': 'Long',
                    'EntryTime': data.index[i],
                    'EntryPrice': entry_price,
                    'StopLoss': stop_loss,
                    'TakeProfit': take_profit,
                    'Qty': qty,
                    'ExitPrice': np.nan,
                    'ExitTime': np.nan,
                    'Profit': np.nan,
                    'Outcome': 'Open'
                }
                current_trades.append(new_trade)
            elif data['ShortCondition'].iloc[i]:
                entry_price = data['close'].iloc[i]
                stop_loss = data['Supertrend'].iloc[i]
                take_profit = entry_price - (abs(entry_price - stop_loss) * 2)
                qty = calculate_position_size(equity, entry_price, stop_loss)
                new_trade = {
                    'Type': 'Short',
                    'EntryTime': data.index[i],
                    'EntryPrice': entry_price,
                    'StopLoss': stop_loss,
                    'TakeProfit': take_profit,
                    'Qty': qty,
                    'ExitPrice': np.nan,
                    'ExitTime': np.nan,
                    'Profit': np.nan,
                    'Outcome': 'Open'
                }
                current_trades.append(new_trade)

        for trade in current_trades:
            if trade['Outcome'] == 'Open':
                if trade['Type'] == 'Long' and data['ShortCondition'].iloc[i]:
                    trade['Outcome'] = 'Closed for Reverse'
                    trade['ExitPrice'] = data['close'].iloc[i]
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                    if not any(t['Type'] == 'Short' and t['Outcome'] == 'Open' for t in current_trades):
                        entry_price = data['close'].iloc[i]
                        stop_loss = data['Supertrend'].iloc[i]
                        take_profit = entry_price - (abs(entry_price - stop_loss) * 2)
                        qty = calculate_position_size(equity, entry_price, stop_loss)
                        reverse_trade = {
                            'Type': 'Short',
                            'EntryTime': data.index[i],
                            'EntryPrice': entry_price,
                            'StopLoss': stop_loss,
                            'TakeProfit': take_profit,
                            'Qty': qty,
                            'ExitPrice': np.nan,
                            'ExitTime': np.nan,
                            'Profit': np.nan,
                            'Outcome': 'Open'
                        }
                        current_trades.append(reverse_trade)
                elif trade['Type'] == 'Short' and data['LongCondition'].iloc[i]:
                    trade['Outcome'] = 'Closed for Reverse'
                    trade['ExitPrice'] = data['close'].iloc[i]
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                    if not any(t['Type'] == 'Long' and t['Outcome'] == 'Open' for t in current_trades):
                        entry_price = data['close'].iloc[i]
                        stop_loss = data['Supertrend'].iloc[i]
                        take_profit = entry_price + (abs(entry_price - stop_loss) * 2)
                        qty = calculate_position_size(equity, entry_price, stop_loss)
                        reverse_trade = {
                            'Type': 'Long',
                            'EntryTime': data.index[i],
                            'EntryPrice': entry_price,
                            'StopLoss': stop_loss,
                            'TakeProfit': take_profit,
                            'Qty': qty,
                            'ExitPrice': np.nan,
                            'ExitTime': np.nan,
                            'Profit': np.nan,
                            'Outcome': 'Open'
                        }
                        current_trades.append(reverse_trade)
                elif trade['Type'] == 'Long' and data['low'].iloc[i] < trade['StopLoss']:
                    trade['Outcome'] = 'Loss'
                    trade['ExitPrice'] = trade['StopLoss']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Long' and data['high'].iloc[i] > trade['TakeProfit']:
                    trade['Outcome'] = 'Win'
                    trade['ExitPrice'] = trade['TakeProfit']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Short' and data['high'].iloc[i] > trade['StopLoss']:
                    trade['Outcome'] = 'Loss'
                    trade['ExitPrice'] = trade['StopLoss']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Short' and data['low'].iloc[i] < trade['TakeProfit']:
                    trade['Outcome'] = 'Win'
                    trade['ExitPrice'] = trade['TakeProfit']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)

        current_trades = [trade for trade in current_trades if trade['Outcome'] == 'Open']
        equity_curve.append(equity)

    trades_df = pd.DataFrame(trades)
    win_rate = len(trades_df[trades_df['Outcome'] == 'Win']) / len(trades_df) if len(trades_df) > 0 else 0
    equity_series = pd.Series(equity_curve)
    drawdown = equity_series / equity_series.cummax() - 1
    max_drawdown = drawdown.min() if len(drawdown) > 0 else 0

    return equity, win_rate, max_drawdown

# Time Series Split for Cross Validation
tscv = TimeSeriesSplit(n_splits=5)

def objective(trial):
    atr_period = trial.suggest_int('atr_period', 5, 21)
    multiplier = trial.suggest_uniform('multiplier', 1.5, 4.0)
    fast_length = trial.suggest_int('fast_length', 5, 120)
    slow_length = trial.suggest_int('slow_length', 10, 150)
    signal_length = trial.suggest_int('signal_length', 5, 115)

    cv_results = []
    for train_index, test_index in tscv.split(data):
        train_data = data.iloc[train_index]
        test_data = data.iloc[test_index]
        final_equity, win_rate, max_drawdown = run_backtest(train_data, atr_period, multiplier, fast_length, slow_length, signal_length)
        cv_results.append(final_equity)
    return -np.mean(cv_results)

study = optuna.create_study(direction='minimize')
study.optimize(objective, n_trials=200)

best_params = study.best_params
print(f"Refined Best parameters: {best_params}")

# Collect all results
results = []

for trial in study.trials:
    params = trial.params
    final_equity, win_rate, max_drawdown = run_backtest(data.copy(), params['atr_period'], params['multiplier'], params['fast_length'], params['slow_length'], params['signal_length'])
    results.append((params, final_equity, win_rate, max_drawdown))

results_df = pd.DataFrame(results, columns=['params', 'final_equity', 'win_rate', 'max_drawdown'])

# Print the 10 best combinations for net profit
print("Top 10 Combinations by Net Profit:")
print(results_df.nlargest(10, 'final_equity'))

# Print the 10 best combinations for win rate
print("Top 10 Combinations by Win Rate:")
print(results_df.nlargest(10, 'win_rate'))

# Print the 10 best combinations for drawdown
print("Top 10 Combinations by Lowest Drawdown:")
print(results_df.nsmallest(10, 'max_drawdown'))

# With walk forward
import numpy as np
import pandas as pd
import talib as ta
from datetime import datetime, time
from skopt import gp_minimize, dummy_minimize
from skopt.space import Integer, Real
from skopt.utils import use_named_args
from google.colab import drive
from sklearn.model_selection import TimeSeriesSplit

drive.mount('/content/drive')

# Define the path to your CSV file in Google Drive
file_path = '/content/drive/My Drive/GBEBROKERS_EURUSD, 5 MARZO.csv'

# Read the CSV file into a DataFrame
data = pd.read_csv(file_path)

# Select only the required columns
data = data[['time', 'open', 'high', 'low', 'close']]

# Convert the 'time' column to datetime
data['time'] = pd.to_datetime(data['time'], unit='s', errors='coerce')
data.dropna(subset=['time'], inplace=True)
data.set_index('time', inplace=True)

def calculate_supertrend(data, atr_period, multiplier):
    data['ATR'] = ta.ATR(data['high'], data['low'], data['close'], timeperiod=atr_period)
    data['hl2'] = (data['high'] + data['low']) / 2
    data['Upper_Band'] = data['hl2'] - (multiplier * data['ATR'])
    data['Lower_Band'] = data['hl2'] + (multiplier * data['ATR'])
    data['Supertrend'] = np.nan
    data['Trend'] = np.nan

    for i in range(1, len(data)):
        if np.isnan(data['Trend'].iloc[i-1]):
            data.loc[data.index[i], 'Trend'] = 1
        elif data['close'].iloc[i] > data['Lower_Band'].iloc[i-1]:
            data.loc[data.index[i], 'Trend'] = 1
        elif data['close'].iloc[i] < data['Upper_Band'].iloc[i-1]:
            data.loc[data.index[i], 'Trend'] = -1
        else:
            data.loc[data.index[i], 'Trend'] = data['Trend'].iloc[i-1]

        if data['Trend'].iloc[i] == 1:
            data.loc[data.index[i], 'Upper_Band'] = max(data['Upper_Band'].iloc[i], data['Upper_Band'].iloc[i-1])
        else:
            data.loc[data.index[i], 'Lower_Band'] = min(data['Lower_Band'].iloc[i], data['Lower_Band'].iloc[i-1])

        supertrend_value = data['Upper_Band'].iloc[i] if data['Trend'].iloc[i] == 1 else data['Lower_Band'].iloc[i]
        data.loc[data.index[i], 'Supertrend'] = round(supertrend_value, 5)

    return data

def run_backtest(data, atr_period, multiplier, fast_length, slow_length, signal_length):
    if fast_length >= slow_length or fast_length <= 0 or slow_length <= 0:
        return 0, 0, 0

    data = calculate_supertrend(data, atr_period, multiplier)

    try:
        data['MACD'], data['Signal'], data['Hist'] = ta.MACD(data['close'], fastperiod=fast_length, slowperiod=slow_length, signalperiod=signal_length)
    except Exception as e:
        return 0, 0, 0

    data['MACD'] = data['MACD'].round(5)
    data['Signal'] = data['Signal'].round(5)
    data['Hist'] = data['Hist'].round(5)

    if not pd.api.types.is_datetime64_any_dtype(data.index):
        data.index = pd.to_datetime(data.index)

    def within_time_range(timestamp):
        return time(6, 30) <= timestamp.time() <= time(19, 30)

    data['WithinTime'] = data.index.map(within_time_range)

    data['LongCondition'] = (data['Trend'] == 1) & (data['MACD'] > data['Signal']) & (data['close'] > data['Supertrend']) & (data['Trend'].shift(1) == -1) & data['WithinTime']
    data['ShortCondition'] = (data['Trend'] == -1) & (data['MACD'] < data['Signal']) & (data['close'] < data['Supertrend']) & (data['Trend'].shift(1) == 1) & data['WithinTime']

    initial_equity = 100000
    equity = initial_equity

    def calculate_position_size(equity, entry_price, stop_loss_price):
        risk_per_trade = equity * 0.01
        risk_pips = abs(entry_price - stop_loss_price)
        qty = risk_per_trade / risk_pips
        return qty

    trades = []
    equity_curve = [equity]
    current_trades = []

    for i in range(1, len(data)):
        if data['LongCondition'].iloc[i] or data['ShortCondition'].iloc[i]:
            if data['LongCondition'].iloc[i]:
                entry_price = data['close'].iloc[i]
                stop_loss = data['Supertrend'].iloc[i]
                take_profit = entry_price + (abs(entry_price - stop_loss) * 2)
                qty = calculate_position_size(equity, entry_price, stop_loss)
                new_trade = {
                    'Type': 'Long',
                    'EntryTime': data.index[i],
                    'EntryPrice': entry_price,
                    'StopLoss': stop_loss,
                    'TakeProfit': take_profit,
                    'Qty': qty,
                    'ExitPrice': np.nan,
                    'ExitTime': np.nan,
                    'Profit': np.nan,
                    'Outcome': 'Open'
                }
                current_trades.append(new_trade)
            elif data['ShortCondition'].iloc[i]:
                entry_price = data['close'].iloc[i]
                stop_loss = data['Supertrend'].iloc[i]
                take_profit = entry_price - (abs(entry_price - stop_loss) * 2)
                qty = calculate_position_size(equity, entry_price, stop_loss)
                new_trade = {
                    'Type': 'Short',
                    'EntryTime': data.index[i],
                    'EntryPrice': entry_price,
                    'StopLoss': stop_loss,
                    'TakeProfit': take_profit,
                    'Qty': qty,
                    'ExitPrice': np.nan,
                    'ExitTime': np.nan,
                    'Profit': np.nan,
                    'Outcome': 'Open'
                }
                current_trades.append(new_trade)

        for trade in current_trades:
            if trade['Outcome'] == 'Open':
                if trade['Type'] == 'Long' and data['ShortCondition'].iloc[i]:
                    trade['Outcome'] = 'Closed for Reverse'
                    trade['ExitPrice'] = data['close'].iloc[i]
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                    if not any(t['Type'] == 'Short' and t['Outcome'] == 'Open' for t in current_trades):
                        entry_price = data['close'].iloc[i]
                        stop_loss = data['Supertrend'].iloc[i]
                        take_profit = entry_price - (abs(entry_price - stop_loss) * 2)
                        qty = calculate_position_size(equity, entry_price, stop_loss)
                        reverse_trade = {
                            'Type': 'Short',
                            'EntryTime': data.index[i],
                            'EntryPrice': entry_price,
                            'StopLoss': stop_loss,
                            'TakeProfit': take_profit,
                            'Qty': qty,
                            'ExitPrice': np.nan,
                            'ExitTime': np.nan,
                            'Profit': np.nan,
                            'Outcome': 'Open'
                        }
                        current_trades.append(reverse_trade)
                elif trade['Type'] == 'Short' and data['LongCondition'].iloc[i]:
                    trade['Outcome'] = 'Closed for Reverse'
                    trade['ExitPrice'] = data['close'].iloc[i]
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                    if not any(t['Type'] == 'Long' and t['Outcome'] == 'Open' for t in current_trades):
                        entry_price = data['close'].iloc[i]
                        stop_loss = data['Supertrend'].iloc[i]
                        take_profit = entry_price + (abs(entry_price - stop_loss) * 2)
                        qty = calculate_position_size(equity, entry_price, stop_loss)
                        reverse_trade = {
                            'Type': 'Long',
                            'EntryTime': data.index[i],
                            'EntryPrice': entry_price,
                            'StopLoss': stop_loss,
                            'TakeProfit': take_profit,
                            'Qty': qty,
                            'ExitPrice': np.nan,
                            'ExitTime': np.nan,
                            'Profit': np.nan,
                            'Outcome': 'Open'
                        }
                        current_trades.append(reverse_trade)
                elif trade['Type'] == 'Long' and data['low'].iloc[i] < trade['StopLoss']:
                    trade['Outcome'] = 'Loss'
                    trade['ExitPrice'] = trade['StopLoss']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Long' and data['high'].iloc[i] > trade['TakeProfit']:
                    trade['Outcome'] = 'Win'
                    trade['ExitPrice'] = trade['TakeProfit']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['ExitPrice'] - trade['EntryPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Short' and data['high'].iloc[i] > trade['StopLoss']:
                    trade['Outcome'] = 'Loss'
                    trade['ExitPrice'] = trade['StopLoss']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)
                elif trade['Type'] == 'Short' and data['low'].iloc[i] < trade['TakeProfit']:
                    trade['Outcome'] = 'Win'
                    trade['ExitPrice'] = trade['TakeProfit']
                    trade['ExitTime'] = data.index[i]
                    trade['Profit'] = (trade['EntryPrice'] - trade['ExitPrice']) * trade['Qty']
                    equity += trade['Profit']
                    trades.append(trade)

        current_trades = [trade for trade in current_trades if trade['Outcome'] == 'Open']
        equity_curve.append(equity)

    trades_df = pd.DataFrame(trades)
    win_rate = len(trades_df[trades_df['Outcome'] == 'Win']) / len(trades_df) if len(trades_df) > 0 else 0
    equity_series = pd.Series(equity_curve)
    drawdown = equity_series / equity_series.cummax() - 1
    max_drawdown = drawdown.min() if len(drawdown) > 0 else 0

    return equity, win_rate, max_drawdown

space = [
    Integer(7, 21, name='atr_period'),
    Real(1.5, 4.0, name='multiplier'),
    Integer(5, 80, name='fast_length'),
    Integer(10, 150, name='slow_length'),
    Integer(5, 90, name='signal_length')
]

# Time Series Split for Cross Validation
tscv = TimeSeriesSplit(n_splits=5)

@use_named_args(space)
def objective(atr_period, multiplier, fast_length, slow_length, signal_length):
    cv_results = []
    for train_index, test_index in tscv.split(data):
        train_data = data.iloc[train_index]
        test_data = data.iloc[test_index]
        final_equity, win_rate, max_drawdown = run_backtest(train_data, atr_period, multiplier, fast_length, slow_length, signal_length)
        cv_results.append(final_equity)
    return -np.mean(cv_results)

# Perform Initial Random Search
random_search_result = dummy_minimize(objective, space, n_calls=200, random_state=0)
initial_best_params = random_search_result.x
print(f"Initial Best parameters: ATR Period: {initial_best_params[0]}, Multiplier: {initial_best_params[1]}, Fast Length: {initial_best_params[2]}, Slow Length: {initial_best_params[3]}, Signal Length: {initial_best_params[4]}")

# Refine Search with Gaussian Process Optimization
refined_space = [
    Integer(max(1, initial_best_params[0] - 5), min(25, initial_best_params[0] + 5), name='atr_period'),
    Real(max(0.1, initial_best_params[1] - 0.5), min(5.0, initial_best_params[1] + 0.5), name='multiplier'),
    Integer(max(1, initial_best_params[2] - 5), min(50, initial_best_params[2] + 5), name='fast_length'),
    Integer(max(10, initial_best_params[3] - 10), min(150, initial_best_params[3] + 10), name='slow_length'),
    Integer(max(1, initial_best_params[4] - 5), min(50, initial_best_params[4] + 5), name='signal_length')
]

@use_named_args(refined_space)
def refined_objective(atr_period, multiplier, fast_length, slow_length, signal_length):
    cv_results = []
    for train_index, test_index in tscv.split(data):
        train_data = data.iloc[train_index]
        test_data = data.iloc[test_index]
        final_equity, win_rate, max_drawdown = run_backtest(train_data, atr_period, multiplier, fast_length, slow_length, signal_length)
        cv_results.append(final_equity)
    return -np.mean(cv_results)

refined_result = gp_minimize(refined_objective, refined_space, n_calls=50, random_state=0)

best_params = refined_result.x
print(f"Refined Best parameters: ATR Period: {best_params[0]}, Multiplier: {best_params[1]}, Fast Length: {best_params[2]}, Slow Length: {best_params[3]}, Signal Length: {best_params[4]}")

# Collect all results
results = []

for params in refined_result.x_iters:
    final_equity, win_rate, max_drawdown = run_backtest(data.copy(), *params)
    results.append((params, final_equity, win_rate, max_drawdown))

results_df = pd.DataFrame(results, columns=['params', 'final_equity', 'win_rate', 'max_drawdown'])

# Print the 10 best combinations for net profit
print("Top 10 Combinations by Net Profit:")
print(results_df.nlargest(10, 'final_equity'))

# Print the 10 best combinations for win rate
print("Top 10 Combinations by Win Rate:")
print(results_df.nlargest(10, 'win_rate'))

# Print the 10 best combinations for drawdown
print("Top 10 Combinations by Lowest Drawdown:")
print(results_df.nsmallest(10, 'max_drawdown'))

# Commented out IPython magic to ensure Python compatibility.
!pip install scikit-optimize

# Download the source code for TA-Lib
!wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz

# Extract the tarball
!tar -xzf ta-lib-0.4.0-src.tar.gz

# Navigate to the extracted directory
# %cd ta-lib/

# Build and install TA-Lib
!./configure --prefix=/usr
!make
!make install

# Navigate back to the parent directory
# %cd ..

# Install the TA-Lib Python package
!pip install ta-lib
!pip install --upgrade --no-cache-dir git+https://github.com/rongardF/tvdatafeed.git